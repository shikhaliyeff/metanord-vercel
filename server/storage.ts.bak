import { 
  users, 
  type User, 
  type InsertUser,
  contactInquiries,
  type ContactInquiry,
  type InsertContactInquiry,
  quoteRequests,
  type QuoteRequest,
  type InsertQuoteRequest,
  contentVersions,
  type ContentVersion,
  type InsertContentVersion,
  seoSettings,
  type SeoSetting,
  type InsertSeoSetting,
  type SiteContent,
  type InsertSiteContent,
  type Product,
  type InsertProduct,
  // Featured Projects/Case Studies
  type Project,
  type InsertProject,
  // CRM imports
  type CrmClient,
  type InsertCrmClient,
  type CrmActivityLog,
  type InsertCrmActivityLog,
  type CrmEmailLog,
  type InsertCrmEmailLog,
  // Page Builder
  type PageTemplate,
  type InsertPageTemplate,
  type PageComponent,
  type InsertPageComponent,
  type CustomPage,
  type InsertCustomPage,
  type CrmEmailTemplate,
  type InsertCrmEmailTemplate,
  // New advanced features imports
  type Offer,
  type InsertOffer,
  type AuditLog,
  type InsertAuditLog,
  type Notification,
  type InsertNotification,
  // Document management
  type Document,
  type InsertDocument
} from "@shared/schema";
import fs from 'fs';
import path from 'path';
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";

const scryptAsync = promisify(scrypt);

// Helper functions for password hashing
export async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}

export async function comparePasswords(supplied: string, stored: string) {
  const [hashed, salt] = stored.split(".");
  const hashedBuf = Buffer.from(hashed, "hex");
  const suppliedBuf = (await scryptAsync(supplied, salt, 64)) as Buffer;
  return timingSafeEqual(hashedBuf, suppliedBuf);
}

// Storage interface with CRUD methods
export interface IStorage {
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  verifyUser(username: string, password: string): Promise<User | null>;
  getAllUsers(): Promise<User[]>;
  updateUser(id: number, userData: Partial<InsertUser>): Promise<User | undefined>;
  deleteUser(id: number): Promise<boolean>;
  updateUserLastLogin(id: number): Promise<User | undefined>;
  
  // Document management
  getAllDocuments(language?: string, documentType?: string, productCategory?: string): Promise<Document[]>;
  getDocument(id: number): Promise<Document | undefined>;
  createDocument(document: InsertDocument): Promise<Document>;
  updateDocument(id: number, document: Partial<InsertDocument>): Promise<Document | undefined>;
  deleteDocument(id: number): Promise<boolean>;
  incrementDownloadCount(id: number): Promise<Document | undefined>;
  
  // Contact Inquiries management
  createContactInquiry(inquiry: InsertContactInquiry): Promise<ContactInquiry>;
  getAllContactInquiries(filters?: { status?: string; archived?: boolean }): Promise<ContactInquiry[]>;
  updateInquiryStatus(inquiryId: number, status: string): Promise<ContactInquiry | undefined>;
  archiveInquiry(inquiryId: number, archived: boolean): Promise<ContactInquiry | undefined>;
  exportContactInquiries(format: 'json' | 'csv', filters?: { status?: string; archived?: boolean }): Promise<string>;
  
  // Quote Requests management
  createQuoteRequest(request: InsertQuoteRequest): Promise<QuoteRequest>;
  getAllQuoteRequests(filters?: { status?: string; archived?: boolean }): Promise<QuoteRequest[]>;
  updateQuoteRequestStatus(requestId: number, status: string): Promise<QuoteRequest | undefined>;
  archiveQuoteRequest(requestId: number, archived: boolean): Promise<QuoteRequest | undefined>;
  exportQuoteRequests(format: 'json' | 'csv', filters?: { status?: string; archived?: boolean }): Promise<string>;
  
  // Content versioning
  createContentVersion(version: InsertContentVersion): Promise<ContentVersion>;
  getContentVersions(contentType: string, contentId?: string): Promise<ContentVersion[]>;
  getLatestContentVersion(contentType: string, contentId?: string): Promise<ContentVersion | undefined>;
  
  // SEO management
  getSeoSettings(pagePath: string, language?: string): Promise<SeoSetting | undefined>;
  getAllSeoSettings(language?: string): Promise<SeoSetting[]>;
  updateSeoSettings(settings: InsertSeoSetting): Promise<SeoSetting>;
  
  // Site content management
  getSiteContent(section: string, key: string, language?: string): Promise<SiteContent | undefined>;
  getAllSiteContent(section?: string, language?: string): Promise<SiteContent[]>;
  updateSiteContent(content: InsertSiteContent): Promise<SiteContent>;
  
  // Product management
  getProduct(productId: string, language?: string): Promise<Product | undefined>;
  getAllProducts(category?: string, language?: string): Promise<Product[]>;
  createProduct(product: InsertProduct): Promise<Product>;
  updateProduct(productId: string, product: Partial<InsertProduct>): Promise<Product | undefined>;
  deleteProduct(productId: string): Promise<boolean>;
  
  // Product-Document relationships
  getProductDocuments(productId: string): Promise<Document[]>;
  addDocumentToProduct(productId: string, documentId: number): Promise<ProductDocument>;
  removeDocumentFromProduct(productId: string, documentId: number): Promise<boolean>;
  
  // CRM Client management
  createCrmClient(client: InsertCrmClient): Promise<CrmClient>;
  getCrmClient(id: number): Promise<CrmClient | undefined>;
  getCrmClientByEmail(email: string): Promise<CrmClient | undefined>;
  getAllCrmClients(filters?: {
    name?: string;
    company?: string;
    country?: string;
    productRef?: string;
    leadStatus?: string;
  }): Promise<CrmClient[]>;
  updateCrmClient(id: number, updates: Partial<InsertCrmClient>): Promise<CrmClient | undefined>;
  deleteCrmClient(id: number): Promise<boolean>;
  
  // CRM Activity Log management
  createCrmActivityLog(activityLog: InsertCrmActivityLog): Promise<CrmActivityLog>;
  getCrmActivityLogs(clientId: number): Promise<CrmActivityLog[]>;
  
  // CRM Email Log management
  createCrmEmailLog(emailLog: InsertCrmEmailLog): Promise<CrmEmailLog>;
  getCrmEmailLogs(clientId: number): Promise<CrmEmailLog[]>;
  
  // CRM Email Template management
  createCrmEmailTemplate(template: InsertCrmEmailTemplate): Promise<CrmEmailTemplate>;
  getAllCrmEmailTemplates(): Promise<CrmEmailTemplate[]>;
  getCrmEmailTemplate(id: number): Promise<CrmEmailTemplate | undefined>;
  updateCrmEmailTemplate(id: number, updates: Partial<InsertCrmEmailTemplate>): Promise<CrmEmailTemplate | undefined>;
  deleteCrmEmailTemplate(id: number): Promise<boolean>;

  // Offer management
  createOffer(offer: InsertOffer): Promise<Offer>;
  getOffer(id: number): Promise<Offer | undefined>;
  getOfferByNumber(offerNumber: string): Promise<Offer | undefined>;
  getClientOffers(clientId: number): Promise<Offer[]>;
  getAllOffers(filters?: {
    status?: string;
    fromDate?: Date;
    toDate?: Date;
    minAmount?: number;
    maxAmount?: number;
  }): Promise<Offer[]>;
  updateOffer(id: number, updates: Partial<InsertOffer>): Promise<Offer | undefined>;
  deleteOffer(id: number): Promise<boolean>;

  // Audit Log management
  createAuditLog(log: InsertAuditLog): Promise<AuditLog>;
  getAuditLogs(filters?: {
    userId?: number;
    action?: string;
    resourceType?: string;
    resourceId?: string;
    fromDate?: Date;
    toDate?: Date;
  }): Promise<AuditLog[]>;

  // Notification management
  createNotification(notification: InsertNotification): Promise<Notification>;
  getUserNotifications(userId: number, includeRead?: boolean): Promise<Notification[]>;
  markNotificationAsRead(id: number): Promise<boolean>;
  markAllNotificationsAsRead(userId: number): Promise<boolean>;
  deleteNotification(id: number): Promise<boolean>;

  // Featured Projects (Case Studies) management
  createProject(project: InsertProject): Promise<Project>;
  getProject(id: number): Promise<Project | undefined>;
  getProjectBySlug(slug: string, language?: string): Promise<Project | undefined>;
  getAllProjects(filters?: {
    published?: boolean;
    language?: string;
    productTag?: string;
    year?: number;
  }): Promise<Project[]>;
  updateProject(id: number, updates: Partial<InsertProject>): Promise<Project | undefined>;
  deleteProject(id: number): Promise<boolean>;

  // Visual Page Builder management
  // Page Templates
  createPageTemplate(template: InsertPageTemplate): Promise<PageTemplate>;
  getPageTemplate(id: number): Promise<PageTemplate | undefined>;
  getPageTemplateBySlug(slug: string): Promise<PageTemplate | undefined>;
  getAllPageTemplates(category?: string): Promise<PageTemplate[]>;
  updatePageTemplate(id: number, template: Partial<InsertPageTemplate>): Promise<PageTemplate | undefined>;
  deletePageTemplate(id: number): Promise<boolean>;
  
  // Page Components
  createPageComponent(component: InsertPageComponent): Promise<PageComponent>;
  getPageComponent(id: number): Promise<PageComponent | undefined>;
  getAllPageComponents(category?: string): Promise<PageComponent[]>;
  updatePageComponent(id: number, component: Partial<InsertPageComponent>): Promise<PageComponent | undefined>;
  deletePageComponent(id: number): Promise<boolean>;
  
  // Custom Pages
  createCustomPage(page: InsertCustomPage): Promise<CustomPage>;
  getCustomPage(id: number): Promise<CustomPage | undefined>;
  getCustomPageBySlug(slug: string, language?: string): Promise<CustomPage | undefined>;
  getAllCustomPages(status?: string, language?: string): Promise<CustomPage[]>;
  updateCustomPage(id: number, page: Partial<InsertCustomPage>): Promise<CustomPage | undefined>;
  publishCustomPage(id: number): Promise<CustomPage | undefined>;
  unpublishCustomPage(id: number): Promise<CustomPage | undefined>;
  deleteCustomPage(id: number): Promise<boolean>;
  
  // Page Versions
  createPageVersion(version: InsertPageVersion): Promise<PageVersion>;
  getPageVersion(id: number): Promise<PageVersion | undefined>;
  getPageVersionsByPageId(pageId: number): Promise<PageVersion[]>;
  getActivePageVersion(pageId: number): Promise<PageVersion | undefined>;
  updatePageVersion(id: number, updates: Partial<InsertPageVersion>): Promise<PageVersion | undefined>;
  setActivePageVersion(id: number): Promise<PageVersion | undefined>;
  deletePageVersion(id: number): Promise<boolean>;

  // Admin functions
  exportToJson(): Promise<string>;
  importFromJson(jsonData: string): Promise<boolean>;
}

export class MemStorage implements IStorage {
  private users: Map<number, User>;
  private contactInquiries: Map<number, ContactInquiry>;
  private quoteRequests: Map<number, QuoteRequest>;
  private contentVersions: Map<number, ContentVersion>;
  private seoSettings: Map<number, SeoSetting>;
  private siteContent: Map<string, SiteContent>;
  private products: Map<string, Product>;
  
  // CRM data stores
  private crmClients: Map<number, CrmClient>;
  private crmActivityLogs: Map<number, CrmActivityLog>;
  private crmEmailLogs: Map<number, CrmEmailLog>;
  private crmEmailTemplates: Map<number, CrmEmailTemplate>;
  
  // Advanced features data stores
  private offers: Map<number, Offer>;
  private auditLogs: Map<number, AuditLog>;
  private documents: Map<number, Document>;
  private notifications: Map<number, Notification>;
  private productDocuments: Map<number, ProductDocument>;
  
  // Featured Projects data store
  private projects: Map<number, Project>;
  
  // Page Builder data stores
  private pageTemplates: Map<number, PageTemplate>;
  private pageComponents: Map<number, PageComponent>;
  private customPages: Map<number, CustomPage>;
  private pageVersions: Map<number, PageVersion>;
  
  // Document management has already been declared in Advanced features
  
  userCurrentId: number;
  inquiryCurrentId: number;
  projectCurrentId: number;
  quoteRequestCurrentId: number;
  contentVersionCurrentId: number;
  seoSettingCurrentId: number;
  contentCurrentId: number;
  productCurrentId: number;
  crmClientCurrentId: number;
  crmActivityLogCurrentId: number;
  crmEmailLogCurrentId: number;
  crmEmailTemplateCurrentId: number;
  offerCurrentId: number;
  auditLogCurrentId: number;
  notificationCurrentId: number;
  pageTemplateCurrentId: number;
  pageComponentCurrentId: number;
  customPageCurrentId: number;
  documentCurrentId: number;
  
  // Path to store JSON data
  private dataPath: string;

  constructor() {
    this.users = new Map();
    this.contactInquiries = new Map();
    this.quoteRequests = new Map();
    this.contentVersions = new Map();
    this.seoSettings = new Map();
    this.siteContent = new Map();
    this.products = new Map();
    
    // Initialize CRM data stores
    this.crmClients = new Map();
    this.crmActivityLogs = new Map();
    this.crmEmailLogs = new Map();
    this.crmEmailTemplates = new Map();
    
    // Initialize advanced features data stores
    this.offers = new Map();
    this.auditLogs = new Map();
    this.documents = new Map();
    this.notifications = new Map();
    this.productDocuments = new Map();
    
    // Initialize projects data store
    this.projects = new Map();
    
    // Initialize Page Builder data stores
    this.pageTemplates = new Map();
    this.pageComponents = new Map();
    this.customPages = new Map();
    
    // Documents data store is already initialized in Advanced features
    
    this.userCurrentId = 1;
    this.inquiryCurrentId = 1;
    this.quoteRequestCurrentId = 1;
    this.contentVersionCurrentId = 1;
    this.seoSettingCurrentId = 1;
    this.contentCurrentId = 1;
    this.pageTemplateCurrentId = 1;
    this.pageComponentCurrentId = 1;
    this.customPageCurrentId = 1;
    this.documentCurrentId = 1;
    this.productCurrentId = 1;
    this.projectCurrentId = 1;
    this.crmClientCurrentId = 1;
    this.crmActivityLogCurrentId = 1;
    this.crmEmailLogCurrentId = 1;
    this.crmEmailTemplateCurrentId = 1;
    this.offerCurrentId = 1;
    this.auditLogCurrentId = 1;
    this.notificationCurrentId = 1;
    
    // Set the path for data storage
    this.dataPath = path.join(process.cwd(), 'data');
    
    // Create data directory if it doesn't exist
    if (!fs.existsSync(this.dataPath)) {
      fs.mkdirSync(this.dataPath, { recursive: true });
    }
    
    // Try to load data from JSON files
    this.loadData();
    
    // Create admin user if it doesn't exist
    this.ensureAdminUser();
  }
  
  private async ensureAdminUser() {
    const adminUser = await this.getUserByUsername('admin');
    if (!adminUser) {
      const hashedPassword = await hashPassword('admin123');
      await this.createUser({ 
        username: 'admin', 
        password: hashedPassword, 
        isAdmin: true 
      });
      console.log('Admin user created with default credentials');
    }
  }
  
  private loadData() {
    try {
      // Load users
      const usersPath = path.join(this.dataPath, 'users.json');
      if (fs.existsSync(usersPath)) {
        const userData = JSON.parse(fs.readFileSync(usersPath, 'utf8'));
        userData.forEach((user: User) => {
          this.users.set(user.id, {
            ...user,
            isAdmin: user.isAdmin === undefined ? false : user.isAdmin
          });
          if (user.id >= this.userCurrentId) {
            this.userCurrentId = user.id + 1;
          }
        });
      }
      
      // Load contact inquiries with advanced verification
      const inquiriesPath = path.join(this.dataPath, 'inquiries.json');
      console.log(`[Storage] Loading inquiries from ${inquiriesPath}`);
      if (fs.existsSync(inquiriesPath)) {
        try {
          const inquiryData = JSON.parse(fs.readFileSync(inquiriesPath, 'utf8'));
          console.log(`[Storage] Found ${inquiryData.length} inquiries in file`);
          
          // Clear existing inquiries to ensure we have fresh data
          this.contactInquiries.clear();
          
          inquiryData.forEach((inquiry: ContactInquiry) => {
            // Convert string date back to Date object
            if (inquiry.createdAt) {
              inquiry.createdAt = new Date(inquiry.createdAt);
            } else {
              inquiry.createdAt = new Date();
            }
            
            // Ensure required fields are present
            if (!inquiry.status) inquiry.status = "new";
            if (inquiry.archived === undefined) inquiry.archived = false;
            
            // Add to the map
            this.contactInquiries.set(inquiry.id, inquiry);
            
            // Update the counter if needed
            if (inquiry.id >= this.inquiryCurrentId) {
              this.inquiryCurrentId = inquiry.id + 1;
            }
          });
          
          console.log(`[Storage] Successfully loaded ${this.contactInquiries.size} inquiries`);
        } catch (error) {
          console.error(`[Storage] Error loading inquiries from file:`, error);
        }
      } else {
        console.log(`[Storage] No inquiries file found at ${inquiriesPath}`);
      }
      
      // Load site content
      const contentPath = path.join(this.dataPath, 'content.json');
      if (fs.existsSync(contentPath)) {
        const contentData = JSON.parse(fs.readFileSync(contentPath, 'utf8'));
        contentData.forEach((content: SiteContent) => {
          const key = `${content.section}:${content.key}:${content.language}`;
          this.siteContent.set(key, content);
          if (content.id >= this.contentCurrentId) {
            this.contentCurrentId = content.id + 1;
          }
        });
      }
      
      // Load products
      const productsPath = path.join(this.dataPath, 'products.json');
      if (fs.existsSync(productsPath)) {
        const productData = JSON.parse(fs.readFileSync(productsPath, 'utf8'));
        productData.forEach((product: Product) => {
          const key = `${product.productId}:${product.language}`;
          this.products.set(key, product);
          if (product.id >= this.productCurrentId) {
            this.productCurrentId = product.id + 1;
          }
        });
      }
      
      // Load quote requests
      const quoteRequestsPath = path.join(this.dataPath, 'quote_requests.json');
      if (fs.existsSync(quoteRequestsPath)) {
        const quoteRequestData = JSON.parse(fs.readFileSync(quoteRequestsPath, 'utf8'));
        quoteRequestData.forEach((request: QuoteRequest) => {
          // Convert string date back to Date object
          if (request.createdAt) {
            request.createdAt = new Date(request.createdAt);
          } else {
            request.createdAt = new Date();
          }
          this.quoteRequests.set(request.id, request);
          if (request.id >= this.quoteRequestCurrentId) {
            this.quoteRequestCurrentId = request.id + 1;
          }
        });
      }
      
      // Load content versions
      const contentVersionsPath = path.join(this.dataPath, 'content_versions.json');
      if (fs.existsSync(contentVersionsPath)) {
        const contentVersionData = JSON.parse(fs.readFileSync(contentVersionsPath, 'utf8'));
        contentVersionData.forEach((version: ContentVersion) => {
          // Convert string date back to Date object
          if (version.createdAt) {
            version.createdAt = new Date(version.createdAt);
          } else {
            version.createdAt = new Date();
          }
          this.contentVersions.set(version.id, version);
          if (version.id >= this.contentVersionCurrentId) {
            this.contentVersionCurrentId = version.id + 1;
          }
        });
      }
      
      // Load SEO settings
      const seoSettingsPath = path.join(this.dataPath, 'seo_settings.json');
      if (fs.existsSync(seoSettingsPath)) {
        const seoSettingData = JSON.parse(fs.readFileSync(seoSettingsPath, 'utf8'));
        seoSettingData.forEach((setting: SeoSetting) => {
          this.seoSettings.set(setting.id, setting);
          if (setting.id >= this.seoSettingCurrentId) {
            this.seoSettingCurrentId = setting.id + 1;
          }
        });
      }
      
      // Load CRM clients
      const crmClientsPath = path.join(this.dataPath, 'crm_clients.json');
      if (fs.existsSync(crmClientsPath)) {
        const crmClientData = JSON.parse(fs.readFileSync(crmClientsPath, 'utf8'));
        crmClientData.forEach((client: CrmClient) => {
          // Convert string dates back to Date objects
          if (client.createdAt) {
            client.createdAt = new Date(client.createdAt);
          } else {
            client.createdAt = new Date();
          }
          if (client.updatedAt) {
            client.updatedAt = new Date(client.updatedAt);
          } else {
            client.updatedAt = new Date();
          }
          if (client.nextFollowup) {
            client.nextFollowup = new Date(client.nextFollowup);
          }
          this.crmClients.set(client.id, client);
          if (client.id >= this.crmClientCurrentId) {
            this.crmClientCurrentId = client.id + 1;
          }
        });
      }
      
      // Load CRM activity logs
      const crmActivityLogsPath = path.join(this.dataPath, 'crm_activity_logs.json');
      if (fs.existsSync(crmActivityLogsPath)) {
        const crmActivityLogData = JSON.parse(fs.readFileSync(crmActivityLogsPath, 'utf8'));
        crmActivityLogData.forEach((log: CrmActivityLog) => {
          // Convert string date back to Date object
          if (log.createdAt) {
            log.createdAt = new Date(log.createdAt);
          } else {
            log.createdAt = new Date();
          }
          this.crmActivityLogs.set(log.id, log);
          if (log.id >= this.crmActivityLogCurrentId) {
            this.crmActivityLogCurrentId = log.id + 1;
          }
        });
      }
      
      // Load CRM email logs
      const crmEmailLogsPath = path.join(this.dataPath, 'crm_email_logs.json');
      if (fs.existsSync(crmEmailLogsPath)) {
        const crmEmailLogData = JSON.parse(fs.readFileSync(crmEmailLogsPath, 'utf8'));
        crmEmailLogData.forEach((log: CrmEmailLog) => {
          // Convert string date back to Date object
          if (log.sentAt) {
            log.sentAt = new Date(log.sentAt);
          } else {
            log.sentAt = new Date();
          }
          this.crmEmailLogs.set(log.id, log);
          if (log.id >= this.crmEmailLogCurrentId) {
            this.crmEmailLogCurrentId = log.id + 1;
          }
        });
      }
      
      // Load CRM email templates
      const crmEmailTemplatesPath = path.join(this.dataPath, 'crm_email_templates.json');
      if (fs.existsSync(crmEmailTemplatesPath)) {
        const crmEmailTemplateData = JSON.parse(fs.readFileSync(crmEmailTemplatesPath, 'utf8'));
        crmEmailTemplateData.forEach((template: CrmEmailTemplate) => {
          // Convert string dates back to Date objects
          if (template.createdAt) {
            template.createdAt = new Date(template.createdAt);
          } else {
            template.createdAt = new Date();
          }
          if (template.updatedAt) {
            template.updatedAt = new Date(template.updatedAt);
          } else {
            template.updatedAt = new Date();
          }
          this.crmEmailTemplates.set(template.id, template);
          if (template.id >= this.crmEmailTemplateCurrentId) {
            this.crmEmailTemplateCurrentId = template.id + 1;
          }
        });
      }
      
      // Load projects
      const projectsPath = path.join(this.dataPath, 'projects.json');
      if (fs.existsSync(projectsPath)) {
        const projectsData = JSON.parse(fs.readFileSync(projectsPath, 'utf8'));
        if (projectsData.projects && Array.isArray(projectsData.projects)) {
          projectsData.projects.forEach((projectData: any) => {
            // Convert the old JSON format to match the Project schema
            const project: Project = {
              id: this.projectCurrentId++,
              title: projectData.title?.en || '',
              slug: projectData.id || '',
              description: projectData.description?.en || '',
              summary: projectData.shortDescription?.en || '',
              language: 'en',
              year: projectData.year || new Date().getFullYear(),
              location: projectData.location?.en || '',
              images: projectData.images || [],
              category: projectData.category || 'infrastructure',
              featuredImage: projectData.featuredImage || (projectData.images && projectData.images.length > 0 ? projectData.images[0] : ''),
              published: projectData.published !== undefined ? projectData.published : true,
              featured: projectData.featured !== undefined ? projectData.featured : true,
              productTags: projectData.productTags || [],
              createdAt: new Date(),
              updatedAt: new Date()
            };
            
            this.projects.set(project.id, project);
            
            // Also create localized versions - only if the multilingual data exists
            if (projectData.title && projectData.description && projectData.shortDescription) {
              const languages = ['ru', 'et', 'lv', 'lt', 'pl'];
              languages.forEach(lang => {
                // Make sure all the required fields exist for this language
                if (projectData.title?.[lang] && projectData.description?.[lang] && projectData.shortDescription?.[lang]) {
                  const localizedProject: Project = {
                    ...project,
                    id: this.projectCurrentId++,
                    title: projectData.title[lang] || '',
                    description: projectData.description[lang] || '',
                    summary: projectData.shortDescription[lang] || '',
                    language: lang,
                    location: projectData.location?.[lang] || '',
                  };
                  this.projects.set(localizedProject.id, localizedProject);
                }
              });
            }
          });
        }
      }
      
      // Load custom pages
      const customPagesPath = path.join(this.dataPath, 'custom_pages.json');
      if (fs.existsSync(customPagesPath)) {
        try {
          const customPagesData = JSON.parse(fs.readFileSync(customPagesPath, 'utf8'));
          if (Array.isArray(customPagesData)) {
            customPagesData.forEach((page: CustomPage) => {
              // Convert string dates back to Date objects
              if (typeof page.createdAt === 'string') {
                page.createdAt = new Date(page.createdAt);
              }
              if (typeof page.updatedAt === 'string') {
                page.updatedAt = new Date(page.updatedAt);
              }
              if (typeof page.publishedAt === 'string' && page.publishedAt) {
                page.publishedAt = new Date(page.publishedAt);
              }
              
              this.customPages.set(page.id, page);
              if (page.id >= this.customPageCurrentId) {
                this.customPageCurrentId = page.id + 1;
              }
            });
            console.log(`[Storage] Loaded ${customPagesData.length} custom pages`);
          }
        } catch (error) {
          console.error(`[Storage] Error loading custom pages: ${error}`);
        }
      } else {
        console.log(`[Storage] No custom pages file found at ${customPagesPath}`);
      }
      
      // Load page components
      const pageComponentsPath = path.join(this.dataPath, 'page_components.json');
      if (fs.existsSync(pageComponentsPath)) {
        try {
          const componentsData = JSON.parse(fs.readFileSync(pageComponentsPath, 'utf8'));
          if (Array.isArray(componentsData)) {
            componentsData.forEach((component: PageComponent) => {
              // Convert string dates back to Date objects
              if (typeof component.createdAt === 'string') {
                component.createdAt = new Date(component.createdAt);
              }
              if (typeof component.updatedAt === 'string') {
                component.updatedAt = new Date(component.updatedAt);
              }
              
              this.pageComponents.set(component.id, component);
              if (component.id >= this.pageComponentCurrentId) {
                this.pageComponentCurrentId = component.id + 1;
              }
            });
            console.log(`[Storage] Loaded ${componentsData.length} page components`);
          }
        } catch (error) {
          console.error(`[Storage] Error loading page components: ${error}`);
        }
      }
      
      // Load page templates
      const pageTemplatesPath = path.join(this.dataPath, 'page_templates.json');
      if (fs.existsSync(pageTemplatesPath)) {
        try {
          const templatesData = JSON.parse(fs.readFileSync(pageTemplatesPath, 'utf8'));
          if (Array.isArray(templatesData)) {
            templatesData.forEach((template: PageTemplate) => {
              // Convert string dates back to Date objects
              if (typeof template.createdAt === 'string') {
                template.createdAt = new Date(template.createdAt);
              }
              if (typeof template.updatedAt === 'string') {
                template.updatedAt = new Date(template.updatedAt);
              }
              
              this.pageTemplates.set(template.id, template);
              if (template.id >= this.pageTemplateCurrentId) {
                this.pageTemplateCurrentId = template.id + 1;
              }
            });
            console.log(`[Storage] Loaded ${templatesData.length} page templates`);
          }
        } catch (error) {
          console.error(`[Storage] Error loading page templates: ${error}`);
        }
      }
      
      console.log('Data loaded from JSON files');
    } catch (error) {
      console.error('Error loading data:', error);
    }
  }
  
  private saveData() {
    try {
      // Save users
      fs.writeFileSync(
        path.join(this.dataPath, 'users.json'),
        JSON.stringify(Array.from(this.users.values()), null, 2)
      );
      
      // Save contact inquiries
      fs.writeFileSync(
        path.join(this.dataPath, 'inquiries.json'),
        JSON.stringify(Array.from(this.contactInquiries.values()), null, 2)
      );
      
      // Save site content
      fs.writeFileSync(
        path.join(this.dataPath, 'content.json'),
        JSON.stringify(Array.from(this.siteContent.values()), null, 2)
      );
      
      // Save products
      fs.writeFileSync(
        path.join(this.dataPath, 'products.json'),
        JSON.stringify(Array.from(this.products.values()), null, 2)
      );
      
      // Save custom pages
      fs.writeFileSync(
        path.join(this.dataPath, 'custom_pages.json'),
        JSON.stringify(Array.from(this.customPages.values()), null, 2)
      );
      
      // Save quote requests
      fs.writeFileSync(
        path.join(this.dataPath, 'quote_requests.json'),
        JSON.stringify(Array.from(this.quoteRequests.values()), null, 2)
      );
      
      // Save content versions
      fs.writeFileSync(
        path.join(this.dataPath, 'content_versions.json'),
        JSON.stringify(Array.from(this.contentVersions.values()), null, 2)
      );
      
      // Save SEO settings
      fs.writeFileSync(
        path.join(this.dataPath, 'seo_settings.json'),
        JSON.stringify(Array.from(this.seoSettings.values()), null, 2)
      );
      
      // Save CRM clients
      fs.writeFileSync(
        path.join(this.dataPath, 'crm_clients.json'),
        JSON.stringify(Array.from(this.crmClients.values()), null, 2)
      );
      
      // Save CRM activity logs
      fs.writeFileSync(
        path.join(this.dataPath, 'crm_activity_logs.json'),
        JSON.stringify(Array.from(this.crmActivityLogs.values()), null, 2)
      );
      
      // Save CRM email logs
      fs.writeFileSync(
        path.join(this.dataPath, 'crm_email_logs.json'),
        JSON.stringify(Array.from(this.crmEmailLogs.values()), null, 2)
      );
      
      // Save CRM email templates
      fs.writeFileSync(
        path.join(this.dataPath, 'crm_email_templates.json'),
        JSON.stringify(Array.from(this.crmEmailTemplates.values()), null, 2)
      );
      
      // Save projects 
      fs.writeFileSync(
        path.join(this.dataPath, 'projects_data.json'),
        JSON.stringify(Array.from(this.projects.values()), null, 2)
      );
      
      // Save documents
      fs.writeFileSync(
        path.join(this.dataPath, 'documents.json'),
        JSON.stringify(Array.from(this.documents.values()), null, 2)
      );
      
      // Save custom pages
      fs.writeFileSync(
        path.join(this.dataPath, 'custom_pages.json'),
        JSON.stringify(Array.from(this.customPages.values()), null, 2)
      );
      
      // Save page components
      fs.writeFileSync(
        path.join(this.dataPath, 'page_components.json'),
        JSON.stringify(Array.from(this.pageComponents.values()), null, 2)
      );
      
      // Save page templates
      fs.writeFileSync(
        path.join(this.dataPath, 'page_templates.json'),
        JSON.stringify(Array.from(this.pageTemplates.values()), null, 2)
      );
      
      console.log('Data saved to JSON files');
    } catch (error) {
      console.error('Error saving data:', error);
    }
  }

  async getUser(id: number): Promise<User | undefined> {
    return this.users.get(id);
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.username === username,
    );
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const id = this.userCurrentId++;
    const { username } = insertUser;
    
    const existingUser = await this.getUserByUsername(username);
    if (existingUser) {
      throw new Error(`User with username ${username} already exists`);
    }
    
    const user: User = {
      ...insertUser,
      id,
      role: insertUser.role || "viewer", // Default role is viewer
      isAdmin: insertUser.isAdmin || false,
      lastLogin: null
    };
    
    this.users.set(id, user);
    this.saveData();
    return user;
  }
  
  async getAllUsers(): Promise<User[]> {
    return Array.from(this.users.values());
  }
  
  async updateUser(id: number, userData: Partial<InsertUser>): Promise<User | undefined> {
    const user = this.users.get(id);
    if (!user) return undefined;
    
    // Check if trying to update username and it already exists
    if (userData.username && userData.username !== user.username) {
      const existingUser = await this.getUserByUsername(userData.username);
      if (existingUser) {
        throw new Error(`User with username ${userData.username} already exists`);
      }
    }
    
    // Update the user
    const updatedUser: User = {
      ...user,
      ...userData,
      id: user.id, // Ensure ID doesn't change
      lastLogin: user.lastLogin // Preserve last login
    };
    
    this.users.set(id, updatedUser);
    this.saveData();
    return updatedUser;
  }
  
  async deleteUser(id: number): Promise<boolean> {
    // Prevent deleting the main admin user
    const user = this.users.get(id);
    if (user && user.username === "admin") {
      throw new Error("Cannot delete the main administrator account");
    }
    
    const success = this.users.delete(id);
    if (success) this.saveData();
    return success;
  }
  
  async updateUserLastLogin(id: number): Promise<User | undefined> {
    const user = this.users.get(id);
    if (!user) return undefined;
    
    const updatedUser: User = {
      ...user,
      lastLogin: new Date()
    };
    
    this.users.set(id, updatedUser);
    this.saveData();
    return updatedUser;
  }
  
  // Document Management Methods
  async getAllDocuments(language?: string, documentType?: string, productCategory?: string): Promise<Document[]> {
    const documents = Array.from(this.documents.values());
    
    return documents.filter(doc => {
      let match = true;
      
      if (language && doc.language !== language) {
        match = false;
      }
      
      if (documentType && doc.documentType !== documentType) {
        match = false;
      }
      
      if (productCategory && doc.productCategories && 
          !doc.productCategories.includes(productCategory)) {
        match = false;
      }
      
      return match;
    }).sort((a, b) => {
      // Sort by createdAt date (newest first)
      const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
      const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
      return dateB - dateA;
    });
  }
  
  async getDocument(id: number): Promise<Document | undefined> {
    return this.documents.get(id);
  }
  
  async createDocument(document: InsertDocument): Promise<Document> {
    const id = this.documentCurrentId++;
    const now = new Date();
    
    const newDocument: Document = {
      id,
      title: document.title,
      description: document.description || null,
      filePath: document.filePath,
      fileSize: document.fileSize || null,
      fileType: document.fileType,
      language: document.language || "en",
      documentType: document.documentType,
      productCategories: document.productCategories || null,
      thumbnail: document.thumbnail || null,
      downloads: 0,
      tags: document.tags || [],
      createdAt: now,
      updatedAt: now,
      isPublic: document.isPublic === undefined ? true : document.isPublic,
      createdBy: document.createdBy || null
    };
    
    this.documents.set(id, newDocument);
    this.saveData();
    
    return newDocument;
  }
  
  async updateDocument(id: number, document: Partial<InsertDocument>): Promise<Document | undefined> {
    const existingDocument = this.documents.get(id);
    
    if (!existingDocument) {
      return undefined;
    }
    
    const updatedDocument = {
      ...existingDocument,
      ...document,
      updatedAt: new Date()
    };
    
    this.documents.set(id, updatedDocument);
    this.saveData();
    
    return updatedDocument;
  }
  
  async deleteDocument(id: number): Promise<boolean> {
    const success = this.documents.delete(id);
    if (success) {
      this.saveData();
    }
    return success;
  }
  
  async incrementDownloadCount(id: number): Promise<Document | undefined> {
    const document = this.documents.get(id);
    
    if (!document) {
      return undefined;
    }
    
    const updatedDocument = {
      ...document,
      downloads: (document.downloads || 0) + 1,
      updatedAt: new Date()
    };
    
    this.documents.set(id, updatedDocument);
    this.saveData();
    
    return updatedDocument;
  }
  
  async verifyUser(username: string, password: string): Promise<User | null> {
    const user = await this.getUserByUsername(username);
    if (!user) return null;
    
    const isValid = await comparePasswords(password, user.password);
    return isValid ? user : null;
  }

  async createContactInquiry(insertInquiry: InsertContactInquiry): Promise<ContactInquiry> {
    console.log("[Storage] Creating contact inquiry:", insertInquiry);
    const id = this.inquiryCurrentId++;
    const createdAt = new Date();
    const inquiry: ContactInquiry = { 
      ...insertInquiry, 
      id, 
      createdAt 
    };
    this.contactInquiries.set(id, inquiry);
    
    // Save immediately to ensure persistence
    try {
      this.saveData();
      
      // Additional logging to verify the save
      const inquiriesArray = Array.from(this.contactInquiries.values());
      console.log(`[Storage] Saved ${inquiriesArray.length} inquiries. New inquiry ID: ${id}`);
      
      // Extra verification - read the file to confirm
      const inquiriesPath = path.join(this.dataPath, 'inquiries.json');
      if (fs.existsSync(inquiriesPath)) {
        try {
          const savedData = JSON.parse(fs.readFileSync(inquiriesPath, 'utf8'));
          console.log(`[Storage] Verified ${savedData.length} inquiries in file`);
        } catch (readError) {
          console.error("[Storage] Error verifying saved file:", readError);
        }
      }
    } catch (error) {
      console.error("[Storage] Failed to save inquiry:", error);
    }
    
    return inquiry;
  }

  async getAllContactInquiries(filters?: { status?: string; archived?: boolean }): Promise<ContactInquiry[]> {
    console.log(`[Storage] Getting all contact inquiries with filters:`, filters);
    let inquiries = Array.from(this.contactInquiries.values());
    console.log(`[Storage] Found ${inquiries.length} total inquiries in storage`);
    
    // Apply filters if provided
    if (filters) {
      if (filters.status !== undefined) {
        inquiries = inquiries.filter(inquiry => inquiry.status === filters.status);
        console.log(`[Storage] Filtered to ${inquiries.length} inquiries with status: ${filters.status}`);
      }
      if (filters.archived !== undefined) {
        inquiries = inquiries.filter(inquiry => inquiry.archived === filters.archived);
        console.log(`[Storage] Filtered to ${inquiries.length} inquiries with archived: ${filters.archived}`);
      }
    }
    
    // Sort by creation date (newest first)
    const sortedInquiries = inquiries.sort((a, b) => {
      const dateA = a.createdAt ? a.createdAt.getTime() : 0;
      const dateB = b.createdAt ? b.createdAt.getTime() : 0;
      return dateB - dateA;
    });
    
    // Log first inquiry for debugging if any exist
    if (sortedInquiries.length > 0) {
      console.log('[Storage] First inquiry in results:', {
        id: sortedInquiries[0].id,
        name: sortedInquiries[0].name,
        email: sortedInquiries[0].email,
        createdAt: sortedInquiries[0].createdAt
      });
    } else {
      console.log('[Storage] No inquiries found after applying filters');
    }
    
    return sortedInquiries;
  }
  
  // Get only archived contact inquiries
  async getArchivedContactInquiries(): Promise<ContactInquiry[]> {
    return this.getAllContactInquiries({ archived: true });
  }
  
  // Get only active (not archived) contact inquiries
  async getActiveContactInquiries(): Promise<ContactInquiry[]> {
    return this.getAllContactInquiries({ archived: false });
  }
  
  // Site content methods
  async getSiteContent(section: string, key: string, language: string = 'en'): Promise<SiteContent | undefined> {
    const contentKey = `${section}:${key}:${language}`;
    return this.siteContent.get(contentKey);
  }
  
  async getAllSiteContent(section?: string, language: string = 'en'): Promise<SiteContent[]> {
    const allContent = Array.from(this.siteContent.values());
    
    // Filter by section and language if provided
    return allContent.filter(content => {
      const sectionMatch = section ? content.section === section : true;
      const languageMatch = content.language === language;
      return sectionMatch && languageMatch;
    });
  }
  
  async updateSiteContent(content: InsertSiteContent): Promise<SiteContent> {
    const contentKey = `${content.section}:${content.key}:${content.language}`;
    const existingContent = this.siteContent.get(contentKey);
    
    if (existingContent) {
      // Update existing content
      const updatedContent: SiteContent = {
        ...existingContent,
        ...content
      };
      
      this.siteContent.set(contentKey, updatedContent);
      this.saveData();
      return updatedContent;
    } else {
      // Create new content
      const id = this.contentCurrentId++;
      const newContent: SiteContent = {
        ...content,
        id
      };
      
      this.siteContent.set(contentKey, newContent);
      this.saveData();
      return newContent;
    }
  }
  
  // Product methods
  async getProduct(productId: string, language: string = 'en'): Promise<Product | undefined> {
    const productKey = `${productId}:${language}`;
    return this.products.get(productKey);
  }
  
  async getAllProducts(category?: string, language: string = 'en'): Promise<Product[]> {
    const allProducts = Array.from(this.products.values());
    
    // Filter by category and language if provided
    return allProducts.filter(product => {
      const categoryMatch = category ? product.category === category : true;
      const languageMatch = product.language === language;
      return categoryMatch && languageMatch;
    });
  }
  
  async createProduct(product: InsertProduct): Promise<Product> {
    const id = this.productCurrentId++;
    const productKey = `${product.productId}:${product.language}`;
    
    const newProduct: Product = {
      ...product,
      id
    };
    
    this.products.set(productKey, newProduct);
    this.saveData();
    return newProduct;
  }
  
  async updateProduct(productId: string, updates: Partial<InsertProduct>): Promise<Product | undefined> {
    const language = updates.language || 'en';
    const productKey = `${productId}:${language}`;
    const existingProduct = this.products.get(productKey);
    
    if (!existingProduct) return undefined;
    
    const updatedProduct: Product = {
      ...existingProduct,
      ...updates
    };
    
    this.products.set(productKey, updatedProduct);
    this.saveData();
    return updatedProduct;
  }
  
  async deleteProduct(productId: string): Promise<boolean> {
    // Delete product in all languages
    let deleted = false;
    for (const [key, product] of this.products.entries()) {
      if (product.productId === productId) {
        this.products.delete(key);
        deleted = true;
      }
    }
    
    if (deleted) {
      // Also delete any product-document associations
      const productDocumentIds: number[] = [];
      for (const [id, relation] of this.productDocuments.entries()) {
        if (relation.productId === productId) {
          productDocumentIds.push(id);
        }
      }
      
      productDocumentIds.forEach(id => this.productDocuments.delete(id));
      this.saveData();
    }
    
    return deleted;
  }
  
  // Product-Document relationship methods
  private productDocumentCurrentId = 1;
  
  async getProductDocuments(productId: string): Promise<Document[]> {
    const relations = Array.from(this.productDocuments.values())
      .filter(relation => relation.productId === productId);
    
    const documentIds = relations.map(relation => relation.documentId);
    const documents = Array.from(this.documents.values())
      .filter(doc => documentIds.includes(doc.id));
      
    return documents;
  }
  
  async addDocumentToProduct(productId: string, documentId: number): Promise<ProductDocument> {
    // Check if this association already exists
    const existing = Array.from(this.productDocuments.values())
      .find(relation => relation.productId === productId && relation.documentId === documentId);
      
    if (existing) {
      return existing;
    }
    
    // Check if product and document exist
    const product = await this.getProduct(productId);
    const document = await this.getDocument(documentId);
    
    if (!product || !document) {
      throw new Error('Product or document not found');
    }
    
    // Create new association
    const newProductDocument: ProductDocument = {
      id: this.productDocumentCurrentId++,
      productId,
      documentId,
      createdAt: new Date(),
    };
    
    this.productDocuments.set(newProductDocument.id, newProductDocument);
    this.saveData();
    
    return newProductDocument;
  }
  
  async removeDocumentFromProduct(productId: string, documentId: number): Promise<boolean> {
    let removed = false;
    
    for (const [id, relation] of this.productDocuments.entries()) {
      if (relation.productId === productId && relation.documentId === documentId) {
        this.productDocuments.delete(id);
        removed = true;
        break;
      }
    }
    
    if (removed) {
      this.saveData();
    }
    
    return removed;
  }
  
  // Contact inquiry status update
  async updateInquiryStatus(inquiryId: number, status: string): Promise<ContactInquiry | undefined> {
    const inquiry = this.contactInquiries.get(inquiryId);
    if (!inquiry) return undefined;
    
    inquiry.status = status;
    this.saveData();
    return inquiry;
  }

  // Archive or unarchive contact inquiry
  async archiveInquiry(inquiryId: number, archived: boolean): Promise<ContactInquiry | undefined> {
    const inquiry = this.contactInquiries.get(inquiryId);
    if (!inquiry) return undefined;
    
    inquiry.archived = archived;
    this.saveData();
    return inquiry;
  }
  
  // Export contact inquiries to JSON or CSV
  async exportContactInquiries(format: 'json' | 'csv', filters?: { status?: string; archived?: boolean }): Promise<string> {
    let inquiries = Array.from(this.contactInquiries.values());
    
    // Apply filters if provided
    if (filters) {
      if (filters.status !== undefined) {
        inquiries = inquiries.filter(inquiry => inquiry.status === filters.status);
      }
      if (filters.archived !== undefined) {
        inquiries = inquiries.filter(inquiry => inquiry.archived === filters.archived);
      }
    }
    
    if (format === 'json') {
      return JSON.stringify(inquiries, null, 2);
    } else {
      // CSV format
      const header = 'ID,Name,Email,Company,Subject,Type,Message,Status,Archived,Created At\n';
      const rows = inquiries.map(inquiry => {
        return `${inquiry.id},"${inquiry.name}","${inquiry.email}","${inquiry.company || ''}","${inquiry.subject || ''}","${inquiry.inquiryType || ''}","${(inquiry.message || '').replace(/"/g, '""')}","${inquiry.status || ''}",${inquiry.archived || false},"${inquiry.createdAt.toISOString()}"`;
      }).join('\n');
      return header + rows;
    }
  }
  
  // Quote requests management
  async createQuoteRequest(request: InsertQuoteRequest): Promise<QuoteRequest> {
    const id = this.quoteRequestCurrentId++;
    const createdAt = new Date();
    const newRequest: QuoteRequest = {
      ...request,
      id,
      createdAt
    };
    
    this.quoteRequests.set(id, newRequest);
    this.saveData();
    return newRequest;
  }
  
  async getAllQuoteRequests(filters?: { status?: string; archived?: boolean }): Promise<QuoteRequest[]> {
    let requests = Array.from(this.quoteRequests.values());
    
    // Apply filters if provided
    if (filters) {
      if (filters.status !== undefined) {
        requests = requests.filter(request => request.status === filters.status);
      }
      if (filters.archived !== undefined) {
        requests = requests.filter(request => request.archived === filters.archived);
      }
    }
    
    // Sort by creation date (newest first)
    return requests.sort((a, b) => {
      const dateA = a.createdAt ? a.createdAt.getTime() : 0;
      const dateB = b.createdAt ? b.createdAt.getTime() : 0;
      return dateB - dateA;
    });
  }
  
  // Get only archived quote requests
  async getArchivedQuoteRequests(): Promise<QuoteRequest[]> {
    return this.getAllQuoteRequests({ archived: true });
  }
  
  // Get only active (not archived) quote requests
  async getActiveQuoteRequests(): Promise<QuoteRequest[]> {
    return this.getAllQuoteRequests({ archived: false });
  }
  
  async updateQuoteRequestStatus(requestId: number, status: string): Promise<QuoteRequest | undefined> {
    const request = this.quoteRequests.get(requestId);
    if (!request) return undefined;
    
    request.status = status;
    this.saveData();
    return request;
  }
  
  // Archive or unarchive quote request
  async archiveQuoteRequest(requestId: number, archived: boolean): Promise<QuoteRequest | undefined> {
    const request = this.quoteRequests.get(requestId);
    if (!request) return undefined;
    
    request.archived = archived;
    this.saveData();
    return request;
  }
  
  // Export quote requests to JSON or CSV
  async exportQuoteRequests(format: 'json' | 'csv', filters?: { status?: string; archived?: boolean }): Promise<string> {
    let requests = Array.from(this.quoteRequests.values());
    
    // Apply filters if provided
    if (filters) {
      if (filters.status !== undefined) {
        requests = requests.filter(request => request.status === filters.status);
      }
      if (filters.archived !== undefined) {
        requests = requests.filter(request => request.archived === filters.archived);
      }
    }
    
    if (format === 'json') {
      return JSON.stringify(requests, null, 2);
    } else {
      // CSV format
      const header = 'ID,Name,Email,Company,Phone,Product ID,Product Name,Quantity,Comment,Status,Archived,Created At\n';
      const rows = requests.map(request => {
        return `${request.id},"${request.name}","${request.email}","${request.company || ''}","${request.phone || ''}","${request.productId || ''}","${request.productName}","${request.quantity || ''}","${(request.comment || '').replace(/"/g, '""')}","${request.status || ''}",${request.archived || false},"${request.createdAt.toISOString()}"`;
      }).join('\n');
      return header + rows;
    }
  }
  
  // Content versioning
  async createContentVersion(version: InsertContentVersion): Promise<ContentVersion> {
    const id = this.contentVersionCurrentId++;
    const createdAt = new Date();
    const newVersion: ContentVersion = {
      ...version,
      id,
      createdAt
    };
    
    this.contentVersions.set(id, newVersion);
    this.saveData();
    return newVersion;
  }
  
  async getContentVersions(contentType: string, contentId?: string): Promise<ContentVersion[]> {
    return Array.from(this.contentVersions.values())
      .filter(version => 
        version.contentType === contentType && 
        (!contentId || version.contentId === contentId)
      )
      .sort((a, b) => b.version - a.version); // Sort by version, descending
  }
  
  async getLatestContentVersion(contentType: string, contentId?: string): Promise<ContentVersion | undefined> {
    const versions = await this.getContentVersions(contentType, contentId);
    return versions.length > 0 ? versions[0] : undefined;
  }
  
  // SEO settings management
  async getSeoSettings(pagePath: string, language: string = 'en'): Promise<SeoSetting | undefined> {
    return Array.from(this.seoSettings.values())
      .find(setting => setting.pagePath === pagePath && setting.language === language);
  }
  
  async getAllSeoSettings(language: string = 'en'): Promise<SeoSetting[]> {
    return Array.from(this.seoSettings.values())
      .filter(setting => setting.language === language);
  }
  
  async updateSeoSettings(settings: InsertSeoSetting): Promise<SeoSetting> {
    // Check if we already have settings for this page and language
    const existingSetting = await this.getSeoSettings(settings.pagePath, settings.language);
    
    if (existingSetting) {
      // Update existing settings
      const updatedSettings: SeoSetting = {
        ...existingSetting,
        ...settings
      };
      
      this.seoSettings.set(existingSetting.id, updatedSettings);
      this.saveData();
      return updatedSettings;
    } else {
      // Create new settings
      const id = this.seoSettingCurrentId++;
      const newSettings: SeoSetting = {
        ...settings,
        id
      };
      
      this.seoSettings.set(id, newSettings);
      this.saveData();
      return newSettings;
    }
  }

  // CRM Client management methods
  async createCrmClient(client: InsertCrmClient): Promise<CrmClient> {
    const id = this.crmClientCurrentId++;
    const now = new Date();
    
    const newClient: CrmClient = {
      ...client,
      id,
      createdAt: now,
      updatedAt: now,
    };
    
    this.crmClients.set(id, newClient);
    this.saveData();
    return newClient;
  }
  
  async getCrmClient(id: number): Promise<CrmClient | undefined> {
    return this.crmClients.get(id);
  }
  
  async getCrmClientByEmail(email: string): Promise<CrmClient | undefined> {
    return Array.from(this.crmClients.values()).find(client => 
      client.email.toLowerCase() === email.toLowerCase()
    );
  }
  
  async getAllCrmClients(filters?: {
    name?: string;
    company?: string;
    country?: string;
    productRef?: string;
    leadStatus?: string;
  }): Promise<CrmClient[]> {
    let clients = Array.from(this.crmClients.values());
    
    // Apply filters if provided
    if (filters) {
      if (filters.name) {
        clients = clients.filter(client => 
          client.name.toLowerCase().includes(filters.name!.toLowerCase())
        );
      }
      
      if (filters.company) {
        clients = clients.filter(client => 
          client.company?.toLowerCase().includes(filters.company!.toLowerCase())
        );
      }
      
      if (filters.country) {
        clients = clients.filter(client => 
          client.country?.toLowerCase() === filters.country!.toLowerCase()
        );
      }
      
      if (filters.productRef) {
        clients = clients.filter(client => 
          client.productsInterested?.some(product => 
            product.toLowerCase().includes(filters.productRef!.toLowerCase())
          )
        );
      }
      
      if (filters.leadStatus) {
        clients = clients.filter(client => 
          client.leadStatus?.toLowerCase() === filters.leadStatus!.toLowerCase()
        );
      }
    }
    
    // Sort by most recent first
    return clients.sort((a, b) => 
      new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
    );
  }
  
  async updateCrmClient(id: number, updates: Partial<InsertCrmClient>): Promise<CrmClient | undefined> {
    const client = await this.getCrmClient(id);
    if (!client) return undefined;
    
    const updatedClient: CrmClient = {
      ...client,
      ...updates,
      id,
      updatedAt: new Date(),
    };
    
    this.crmClients.set(id, updatedClient);
    this.saveData();
    return updatedClient;
  }
  
  async deleteCrmClient(id: number): Promise<boolean> {
    const success = this.crmClients.delete(id);
    if (success) {
      this.saveData();
    }
    return success;
  }
  
  // CRM Activity Log management methods
  async createCrmActivityLog(activityLog: InsertCrmActivityLog): Promise<CrmActivityLog> {
    const id = this.crmActivityLogCurrentId++;
    const now = new Date();
    
    const newLog: CrmActivityLog = {
      ...activityLog,
      id,
      createdAt: now,
    };
    
    this.crmActivityLogs.set(id, newLog);
    this.saveData();
    return newLog;
  }
  
  async getCrmActivityLogs(clientId: number): Promise<CrmActivityLog[]> {
    return Array.from(this.crmActivityLogs.values())
      .filter(log => log.clientId === clientId)
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  }
  
  // CRM Email Log management methods
  async createCrmEmailLog(emailLog: InsertCrmEmailLog): Promise<CrmEmailLog> {
    const id = this.crmEmailLogCurrentId++;
    
    const newLog: CrmEmailLog = {
      ...emailLog,
      id,
      sentAt: new Date(),
    };
    
    this.crmEmailLogs.set(id, newLog);
    this.saveData();
    return newLog;
  }
  
  async getCrmEmailLogs(clientId: number): Promise<CrmEmailLog[]> {
    return Array.from(this.crmEmailLogs.values())
      .filter(log => log.clientId === clientId)
      .sort((a, b) => new Date(b.sentAt).getTime() - new Date(a.sentAt).getTime());
  }
  
  // CRM Email Template management methods
  async createCrmEmailTemplate(template: InsertCrmEmailTemplate): Promise<CrmEmailTemplate> {
    const id = this.crmEmailTemplateCurrentId++;
    const now = new Date();
    
    const newTemplate: CrmEmailTemplate = {
      ...template,
      id,
      createdAt: now,
      updatedAt: now,
    };
    
    this.crmEmailTemplates.set(id, newTemplate);
    this.saveData();
    return newTemplate;
  }
  
  async getAllCrmEmailTemplates(): Promise<CrmEmailTemplate[]> {
    return Array.from(this.crmEmailTemplates.values());
  }
  
  async getCrmEmailTemplate(id: number): Promise<CrmEmailTemplate | undefined> {
    return this.crmEmailTemplates.get(id);
  }
  
  async updateCrmEmailTemplate(id: number, updates: Partial<InsertCrmEmailTemplate>): Promise<CrmEmailTemplate | undefined> {
    const template = await this.getCrmEmailTemplate(id);
    if (!template) return undefined;
    
    const updatedTemplate: CrmEmailTemplate = {
      ...template,
      ...updates,
      id,
      updatedAt: new Date(),
    };
    
    this.crmEmailTemplates.set(id, updatedTemplate);
    this.saveData();
    return updatedTemplate;
  }
  
  async deleteCrmEmailTemplate(id: number): Promise<boolean> {
    const success = this.crmEmailTemplates.delete(id);
    if (success) {
      this.saveData();
    }
    return success;
  }
  
  // Offer Management
  async createOffer(offer: InsertOffer): Promise<Offer> {
    const id = this.offerCurrentId++;
    const now = new Date();
    
    const newOffer: Offer = {
      id,
      offerNumber: offer.offerNumber,
      clientId: offer.clientId,
      items: offer.items,
      totalAmount: offer.totalAmount || null,
      currency: offer.currency || 'EUR',
      notes: offer.notes || null,
      terms: offer.terms || null,
      paymentTerms: offer.paymentTerms || null,
      date: offer.date || now,
      expiryDate: offer.expiryDate || null,
      status: offer.status || 'draft',
      createdBy: offer.createdBy || null,
      createdAt: now,
      updatedAt: now
    };
    
    this.offers.set(id, newOffer);
    this.saveData();
    return newOffer;
  }
  
  async getOffer(id: number): Promise<Offer | undefined> {
    return this.offers.get(id);
  }
  
  async getOfferByNumber(offerNumber: string): Promise<Offer | undefined> {
    return Array.from(this.offers.values()).find(
      (offer) => offer.offerNumber === offerNumber
    );
  }
  
  async getClientOffers(clientId: number): Promise<Offer[]> {
    return Array.from(this.offers.values()).filter(
      (offer) => offer.clientId === clientId
    );
  }
  
  async getAllOffers(filters?: {
    status?: string;
    fromDate?: Date;
    toDate?: Date;
    minAmount?: number;
    maxAmount?: number;
  }): Promise<Offer[]> {
    let offers = Array.from(this.offers.values());
    
    if (filters) {
      if (filters.status) {
        offers = offers.filter((offer) => offer.status === filters.status);
      }
      
      if (filters.fromDate) {
        offers = offers.filter(
          (offer) => new Date(offer.date) >= filters.fromDate!
        );
      }
      
      if (filters.toDate) {
        offers = offers.filter(
          (offer) => new Date(offer.date) <= filters.toDate!
        );
      }
      
      if (filters.minAmount && filters.minAmount > 0) {
        offers = offers.filter(
          (offer) => offer.totalAmount !== null && 
                     parseFloat(offer.totalAmount) >= filters.minAmount!
        );
      }
      
      if (filters.maxAmount && filters.maxAmount > 0) {
        offers = offers.filter(
          (offer) => offer.totalAmount !== null && 
                     parseFloat(offer.totalAmount) <= filters.maxAmount!
        );
      }
    }
    
    return offers;
  }
  
  async updateOffer(id: number, updates: Partial<InsertOffer>): Promise<Offer | undefined> {
    const offer = this.offers.get(id);
    if (!offer) return undefined;
    
    const updatedOffer: Offer = {
      ...offer,
      ...updates,
      updatedAt: new Date()
    };
    
    this.offers.set(id, updatedOffer);
    this.saveData();
    return updatedOffer;
  }
  
  async deleteOffer(id: number): Promise<boolean> {
    const success = this.offers.delete(id);
    if (success) {
      this.saveData();
    }
    return success;
  }
  
  // Audit Log Management
  async createAuditLog(log: InsertAuditLog): Promise<AuditLog> {
    const id = this.auditLogCurrentId++;
    
    const newLog: AuditLog = {
      id,
      userId: log.userId || null,
      action: log.action,
      resourceType: log.resourceType,
      resourceId: log.resourceId || null,
      details: log.details || null,
      timestamp: new Date()
    };
    
    this.auditLogs.set(id, newLog);
    this.saveData();
    return newLog;
  }
  
  async getAuditLogs(filters?: {
    userId?: number;
    action?: string;
    resourceType?: string;
    resourceId?: string;
    fromDate?: Date;
    toDate?: Date;
  }): Promise<AuditLog[]> {
    let logs = Array.from(this.auditLogs.values());
    
    if (filters) {
      if (filters.userId) {
        logs = logs.filter((log) => log.userId === filters.userId);
      }
      
      if (filters.action) {
        logs = logs.filter((log) => log.action === filters.action);
      }
      
      if (filters.resourceType) {
        logs = logs.filter((log) => log.resourceType === filters.resourceType);
      }
      
      if (filters.resourceId) {
        logs = logs.filter((log) => log.resourceId === filters.resourceId);
      }
      
      if (filters.fromDate) {
        logs = logs.filter(
          (log) => new Date(log.timestamp) >= filters.fromDate!
        );
      }
      
      if (filters.toDate) {
        logs = logs.filter(
          (log) => new Date(log.timestamp) <= filters.toDate!
        );
      }
    }
    
    // Sort by timestamp, newest first
    return logs.sort((a, b) => 
      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
    );
  }
  
  // Notification Management
  async createNotification(notification: InsertNotification): Promise<Notification> {
    const id = this.notificationCurrentId++;
    
    const newNotification: Notification = {
      id,
      userId: notification.userId,
      title: notification.title,
      message: notification.message,
      type: notification.type,
      read: false,
      resourceType: notification.resourceType || null,
      resourceId: notification.resourceId || null,
      createdAt: new Date()
    };
    
    this.notifications.set(id, newNotification);
    this.saveData();
    return newNotification;
  }
  
  async getUserNotifications(userId: number, includeRead: boolean = false): Promise<Notification[]> {
    let notifications = Array.from(this.notifications.values()).filter(
      (notification) => notification.userId === userId
    );
    
    if (!includeRead) {
      notifications = notifications.filter(
        (notification) => !notification.read
      );
    }
    
    // Sort by creation date, newest first
    return notifications.sort((a, b) => 
      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
  }
  
  async markNotificationAsRead(id: number): Promise<boolean> {
    const notification = this.notifications.get(id);
    if (!notification) return false;
    
    notification.read = true;
    this.notifications.set(id, notification);
    this.saveData();
    return true;
  }
  
  async markAllNotificationsAsRead(userId: number): Promise<boolean> {
    const userNotifications = Array.from(this.notifications.values()).filter(
      (notification) => notification.userId === userId
    );
    
    for (const notification of userNotifications) {
      notification.read = true;
      this.notifications.set(notification.id, notification);
    }
    
    this.saveData();
    return true;
  }
  
  async deleteNotification(id: number): Promise<boolean> {
    const success = this.notifications.delete(id);
    if (success) {
      this.saveData();
    }
    return success;
  }
  
  // Featured Projects (Case Studies) management
  async createProject(project: InsertProject): Promise<Project> {
    const newProject: Project = {
      ...project,
      id: this.projectCurrentId++,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    
    this.projects.set(newProject.id, newProject);
    this.saveData();
    return newProject;
  }
  
  async getProject(id: number): Promise<Project | undefined> {
    return this.projects.get(id);
  }
  
  async getProjectBySlug(slug: string, language = 'en'): Promise<Project | undefined> {
    for (const project of this.projects.values()) {
      if (project.slug === slug && project.language === language) {
        return project;
      }
    }
    return undefined;
  }
  
  async getAllProjects(filters?: {
    published?: boolean;
    language?: string;
    productTag?: string;
    year?: number;
    category?: string;
  }): Promise<Project[]> {
    let projects = Array.from(this.projects.values());
    
    if (filters) {
      if (filters.published !== undefined) {
        projects = projects.filter(p => p.published === filters.published);
      }
      
      if (filters.language) {
        projects = projects.filter(p => p.language === filters.language);
      }
      
      if (filters.productTag) {
        projects = projects.filter(p => 
          p.productTags && p.productTags.includes(filters.productTag!)
        );
      }
      
      if (filters.year) {
        projects = projects.filter(p => p.year === filters.year);
      }
      
      if (filters.category && filters.category !== 'all') {
        projects = projects.filter(p => p.category === filters.category);
      }
    }
    
    // Sort by most recent projects first
    return projects.sort((a, b) => {
      // First sort by featured status
      if (a.featured && !b.featured) return -1;
      if (!a.featured && b.featured) return 1;
      
      // Then sort by date (desc)
      const dateA = a.projectDate || a.createdAt;
      const dateB = b.projectDate || b.createdAt;
      return dateB.getTime() - dateA.getTime();
    });
  }
  
  async updateProject(id: number, updates: Partial<InsertProject>): Promise<Project | undefined> {
    const project = this.projects.get(id);
    if (!project) return undefined;
    
    const updatedProject: Project = {
      ...project,
      ...updates,
      updatedAt: new Date(),
    };
    
    this.projects.set(id, updatedProject);
    this.saveData();
    return updatedProject;
  }
  
  async deleteProject(id: number): Promise<boolean> {
    const exists = this.projects.has(id);
    if (exists) {
      this.projects.delete(id);
      this.saveData();
    }
    return exists;
  }
  
  // Page Builder: Page Templates
  async createPageTemplate(data: Omit<InsertPageTemplate, "id" | "createdAt" | "updatedAt">): Promise<PageTemplate> {
    const id = this.pageTemplateCurrentId++;
    const now = new Date();
    
    const template: PageTemplate = {
      id,
      name: data.name,
      description: data.description || null,
      category: data.category || "general",
      slug: data.slug,
      structure: data.structure,
      thumbnail: data.thumbnail || null,
      isArchived: data.isArchived || false,
      createdAt: now,
      updatedAt: now
    };
    
    this.pageTemplates.set(id, template);
    this.saveData();
    return template;
  }
  
  async getPageTemplate(id: number): Promise<PageTemplate | undefined> {
    return this.pageTemplates.get(id);
  }
  
  async getPageTemplateBySlug(slug: string): Promise<PageTemplate | undefined> {
    return Array.from(this.pageTemplates.values()).find(
      template => template.slug === slug
    );
  }
  
  async getAllPageTemplates(category?: string): Promise<PageTemplate[]> {
    let templates = Array.from(this.pageTemplates.values());
    
    if (category) {
      templates = templates.filter(template => template.category === category);
    }
    
    return templates.sort((a, b) => {
      // First sort by archived status
      if (!a.isArchived && b.isArchived) return -1;
      if (a.isArchived && !b.isArchived) return 1;
      
      // Then sort by name
      return a.name.localeCompare(b.name);
    });
  }
  
  async updatePageTemplate(id: number, updates: Partial<InsertPageTemplate>): Promise<PageTemplate | undefined> {
    const template = this.pageTemplates.get(id);
    if (!template) return undefined;
    
    const updatedTemplate: PageTemplate = {
      ...template,
      ...updates,
      updatedAt: new Date()
    };
    
    this.pageTemplates.set(id, updatedTemplate);
    this.saveData();
    return updatedTemplate;
  }
  
  async deletePageTemplate(id: number): Promise<boolean> {
    const exists = this.pageTemplates.has(id);
    if (exists) {
      this.pageTemplates.delete(id);
      this.saveData();
    }
    return exists;
  }
  
  // Page Builder: Page Components
  async createPageComponent(data: Omit<InsertPageComponent, "id" | "createdAt" | "updatedAt">): Promise<PageComponent> {
    const id = this.pageComponentCurrentId++;
    const now = new Date();
    
    const component: PageComponent = {
      id,
      name: data.name,
      description: data.description || null,
      category: data.category || "general",
      structure: data.structure,
      thumbnail: data.thumbnail || null,
      isSystem: data.isSystem || false,
      isArchived: data.isArchived || false,
      createdAt: now,
      updatedAt: now
    };
    
    this.pageComponents.set(id, component);
    this.saveData();
    return component;
  }
  
  async getPageComponent(id: number): Promise<PageComponent | undefined> {
    return this.pageComponents.get(id);
  }
  
  async getAllPageComponents(category?: string): Promise<PageComponent[]> {
    let components = Array.from(this.pageComponents.values());
    
    if (category) {
      components = components.filter(component => component.category === category);
    }
    
    return components.sort((a, b) => {
      // First sort by system components
      if (a.isSystem && !b.isSystem) return -1;
      if (!a.isSystem && b.isSystem) return 1;
      
      // Then sort by archived status
      if (!a.isArchived && b.isArchived) return -1;
      if (a.isArchived && !b.isArchived) return 1;
      
      // Finally sort by name
      return a.name.localeCompare(b.name);
    });
  }
  
  async updatePageComponent(id: number, updates: Partial<InsertPageComponent>): Promise<PageComponent | undefined> {
    const component = this.pageComponents.get(id);
    if (!component) return undefined;
    
    const updatedComponent: PageComponent = {
      ...component,
      ...updates,
      updatedAt: new Date()
    };
    
    this.pageComponents.set(id, updatedComponent);
    this.saveData();
    return updatedComponent;
  }
  
  async deletePageComponent(id: number): Promise<boolean> {
    const exists = this.pageComponents.has(id);
    if (exists) {
      this.pageComponents.delete(id);
      this.saveData();
    }
    return exists;
  }
  
  // Page Builder: Custom Pages
  async createCustomPage(data: Omit<InsertCustomPage, "id" | "createdAt" | "updatedAt" | "publishedAt">): Promise<CustomPage> {
    const id = this.customPageCurrentId++;
    const now = new Date();
    
    const page: CustomPage = {
      id,
      title: data.title,
      description: data.description || null,
      slug: data.slug,
      language: data.language || "en",
      content: data.content,
      metaTitle: data.metaTitle || data.title,
      metaDescription: data.metaDescription || data.description || null,
      ogImage: data.ogImage || null,
      status: data.status || "draft",
      templateId: data.templateId || null,
      author: data.author || null,
      createdAt: now,
      updatedAt: now,
      publishedAt: data.status === "published" ? now : null
    };
    
    this.customPages.set(id, page);
    this.saveData();
    return page;
  }
  
  async getCustomPage(id: number): Promise<CustomPage | undefined> {
    return this.customPages.get(id);
  }
  
  async getCustomPageBySlug(slug: string, language?: string): Promise<CustomPage | undefined> {
    const pages = Array.from(this.customPages.values()).filter(
      page => page.slug === slug && page.status === "published"
    );
    
    if (!pages.length) return undefined;
    
    // If language is specified, try to find that version first
    if (language) {
      const localizedPage = pages.find(page => page.language === language);
      if (localizedPage) return localizedPage;
    }
    
    // Otherwise return the English version or the first available
    const enPage = pages.find(page => page.language === "en");
    return enPage || pages[0];
  }
  
  async getAllCustomPages(status?: string, language?: string): Promise<CustomPage[]> {
    let pages = Array.from(this.customPages.values());
    
    if (status) {
      pages = pages.filter(page => page.status === status);
    }
    
    if (language) {
      pages = pages.filter(page => page.language === language);
    }
    
    return pages.sort((a, b) => {
      // Sort by status (published first, then draft)
      if (a.status === "published" && b.status !== "published") return -1;
      if (a.status !== "published" && b.status === "published") return 1;
      
      // Then sort by updated date (newest first)
      return b.updatedAt.getTime() - a.updatedAt.getTime();
    });
  }
  
  async updateCustomPage(id: number, updates: Partial<InsertCustomPage>): Promise<CustomPage | undefined> {
    const page = this.customPages.get(id);
    if (!page) return undefined;
    
    const now = new Date();
    const updatedPage: CustomPage = {
      ...page,
      ...updates,
      updatedAt: now,
      // Only update publishedAt if status changed to published and it wasn't published before
      publishedAt: updates.status === "published" && page.status !== "published" 
        ? now 
        : page.publishedAt
    };
    
    this.customPages.set(id, updatedPage);
    this.saveData();
    return updatedPage;
  }
  
  async publishCustomPage(id: number): Promise<CustomPage | undefined> {
    const page = this.customPages.get(id);
    if (!page) return undefined;
    
    const now = new Date();
    const publishedPage: CustomPage = {
      ...page,
      status: "published",
      publishedAt: now,
      updatedAt: now
    };
    
    this.customPages.set(id, publishedPage);
    this.saveData();
    return publishedPage;
  }
  
  async unpublishCustomPage(id: number): Promise<CustomPage | undefined> {
    const page = this.customPages.get(id);
    if (!page) return undefined;
    
    const unpublishedPage: CustomPage = {
      ...page,
      status: "draft",
      updatedAt: new Date()
      // Keep the publishedAt date for historical reference
    };
    
    this.customPages.set(id, unpublishedPage);
    this.saveData();
    return unpublishedPage;
  }
  
  async deleteCustomPage(id: number): Promise<boolean> {
    const exists = this.customPages.has(id);
    if (exists) {
      this.customPages.delete(id);
      this.saveData();
    }
    return exists;
  }
  
  // Admin functions
  async exportToJson(): Promise<string> {
    const exportData = {
      users: Array.from(this.users.values()),
      contactInquiries: Array.from(this.contactInquiries.values()),
      quoteRequests: Array.from(this.quoteRequests.values()),
      contentVersions: Array.from(this.contentVersions.values()),
      seoSettings: Array.from(this.seoSettings.values()),
      siteContent: Array.from(this.siteContent.values()),
      products: Array.from(this.products.values()),
      projects: Array.from(this.projects.values()),
      // CRM data
      crmClients: Array.from(this.crmClients.values()),
      crmActivityLogs: Array.from(this.crmActivityLogs.values()),
      crmEmailLogs: Array.from(this.crmEmailLogs.values()),
      crmEmailTemplates: Array.from(this.crmEmailTemplates.values()),
      // Advanced features data
      offers: Array.from(this.offers.values()),
      auditLogs: Array.from(this.auditLogs.values()),
      notifications: Array.from(this.notifications.values()),
      // Page Builder data
      pageTemplates: Array.from(this.pageTemplates.values()),
      pageComponents: Array.from(this.pageComponents.values()),
      customPages: Array.from(this.customPages.values())
    };
    
    return JSON.stringify(exportData, null, 2);
  }
  
  async importFromJson(jsonData: string): Promise<boolean> {
    try {
      const data = JSON.parse(jsonData);
      
      // Clear existing data
      this.users.clear();
      this.contactInquiries.clear();
      this.quoteRequests.clear();
      this.contentVersions.clear();
      this.seoSettings.clear();
      this.siteContent.clear();
      this.products.clear();
      this.projects.clear();
      
      // Clear CRM data
      this.crmClients.clear();
      this.crmActivityLogs.clear();
      this.crmEmailLogs.clear();
      this.crmEmailTemplates.clear();
      
      // Clear advanced features data
      this.offers.clear();
      this.auditLogs.clear();
      this.notifications.clear();
      
      // Clear Page Builder data
      this.pageTemplates.clear();
      this.pageComponents.clear();
      this.customPages.clear();
      
      // Reset IDs
      this.userCurrentId = 1;
      this.inquiryCurrentId = 1;
      this.quoteRequestCurrentId = 1;
      this.contentVersionCurrentId = 1;
      this.seoSettingCurrentId = 1;
      this.contentCurrentId = 1;
      this.productCurrentId = 1;
      this.projectCurrentId = 1;
      
      // Reset CRM IDs
      this.crmClientCurrentId = 1;
      this.crmActivityLogCurrentId = 1;
      this.crmEmailLogCurrentId = 1;
      this.crmEmailTemplateCurrentId = 1;
      
      // Reset advanced features IDs
      this.offerCurrentId = 1;
      this.auditLogCurrentId = 1;
      this.notificationCurrentId = 1;
      
      // Reset Page Builder IDs
      this.pageTemplateCurrentId = 1;
      this.pageComponentCurrentId = 1;
      this.customPageCurrentId = 1;
      
      // Import users
      if (Array.isArray(data.users)) {
        data.users.forEach((user: User) => {
          this.users.set(user.id, user);
          if (user.id >= this.userCurrentId) {
            this.userCurrentId = user.id + 1;
          }
        });
      }
      
      // Import contact inquiries
      if (Array.isArray(data.contactInquiries)) {
        data.contactInquiries.forEach((inquiry: ContactInquiry) => {
          inquiry.createdAt = new Date(inquiry.createdAt);
          this.contactInquiries.set(inquiry.id, inquiry);
          if (inquiry.id >= this.inquiryCurrentId) {
            this.inquiryCurrentId = inquiry.id + 1;
          }
        });
      }
      
      // Import site content
      if (Array.isArray(data.siteContent)) {
        data.siteContent.forEach((content: SiteContent) => {
          const key = `${content.section}:${content.key}:${content.language}`;
          this.siteContent.set(key, content);
          if (content.id >= this.contentCurrentId) {
            this.contentCurrentId = content.id + 1;
          }
        });
      }
      
      // Import products
      if (Array.isArray(data.products)) {
        data.products.forEach((product: Product) => {
          const key = `${product.productId}:${product.language}`;
          this.products.set(key, product);
          if (product.id >= this.productCurrentId) {
            this.productCurrentId = product.id + 1;
          }
        });
      }
      
      // Import projects
      if (Array.isArray(data.projects)) {
        data.projects.forEach((project: Project) => {
          // Convert string dates back to Date objects
          if (typeof project.createdAt === 'string') {
            project.createdAt = new Date(project.createdAt);
          }
          if (typeof project.updatedAt === 'string') {
            project.updatedAt = new Date(project.updatedAt);
          }
          if (typeof project.projectDate === 'string') {
            project.projectDate = new Date(project.projectDate);
          }
          
          this.projects.set(project.id, project);
          if (project.id >= this.projectCurrentId) {
            this.projectCurrentId = project.id + 1;
          }
        });
      }
      
      // Import CRM clients
      if (Array.isArray(data.crmClients)) {
        data.crmClients.forEach((client: CrmClient) => {
          // Convert string dates back to Date objects
          if (typeof client.createdAt === 'string') {
            client.createdAt = new Date(client.createdAt);
          }
          if (typeof client.updatedAt === 'string') {
            client.updatedAt = new Date(client.updatedAt);
          }
          if (typeof client.nextFollowup === 'string') {
            client.nextFollowup = new Date(client.nextFollowup);
          }
          
          this.crmClients.set(client.id, client);
          if (client.id >= this.crmClientCurrentId) {
            this.crmClientCurrentId = client.id + 1;
          }
        });
      }
      
      // Import CRM activity logs
      if (Array.isArray(data.crmActivityLogs)) {
        data.crmActivityLogs.forEach((log: CrmActivityLog) => {
          if (typeof log.createdAt === 'string') {
            log.createdAt = new Date(log.createdAt);
          }
          
          this.crmActivityLogs.set(log.id, log);
          if (log.id >= this.crmActivityLogCurrentId) {
            this.crmActivityLogCurrentId = log.id + 1;
          }
        });
      }
      
      // Import CRM email logs
      if (Array.isArray(data.crmEmailLogs)) {
        data.crmEmailLogs.forEach((log: CrmEmailLog) => {
          if (typeof log.sentAt === 'string') {
            log.sentAt = new Date(log.sentAt);
          }
          
          this.crmEmailLogs.set(log.id, log);
          if (log.id >= this.crmEmailLogCurrentId) {
            this.crmEmailLogCurrentId = log.id + 1;
          }
        });
      }
      
      // Import CRM email templates
      if (Array.isArray(data.crmEmailTemplates)) {
        data.crmEmailTemplates.forEach((template: CrmEmailTemplate) => {
          if (typeof template.createdAt === 'string') {
            template.createdAt = new Date(template.createdAt);
          }
          if (typeof template.updatedAt === 'string') {
            template.updatedAt = new Date(template.updatedAt);
          }
          
          this.crmEmailTemplates.set(template.id, template);
          if (template.id >= this.crmEmailTemplateCurrentId) {
            this.crmEmailTemplateCurrentId = template.id + 1;
          }
        });
      }
      
      // Import offers
      if (Array.isArray(data.offers)) {
        data.offers.forEach((offer: Offer) => {
          if (typeof offer.createdAt === 'string') {
            offer.createdAt = new Date(offer.createdAt);
          }
          if (typeof offer.updatedAt === 'string') {
            offer.updatedAt = new Date(offer.updatedAt);
          }
          if (typeof offer.date === 'string') {
            offer.date = new Date(offer.date);
          }
          if (offer.expiryDate && typeof offer.expiryDate === 'string') {
            offer.expiryDate = new Date(offer.expiryDate);
          }
          
          this.offers.set(offer.id, offer);
          if (offer.id >= this.offerCurrentId) {
            this.offerCurrentId = offer.id + 1;
          }
        });
      }
      
      // Import audit logs
      if (Array.isArray(data.auditLogs)) {
        data.auditLogs.forEach((log: AuditLog) => {
          if (typeof log.timestamp === 'string') {
            log.timestamp = new Date(log.timestamp);
          }
          
          this.auditLogs.set(log.id, log);
          if (log.id >= this.auditLogCurrentId) {
            this.auditLogCurrentId = log.id + 1;
          }
        });
      }
      
      // Import notifications
      if (Array.isArray(data.notifications)) {
        data.notifications.forEach((notification: Notification) => {
          if (typeof notification.createdAt === 'string') {
            notification.createdAt = new Date(notification.createdAt);
          }
          
          this.notifications.set(notification.id, notification);
          if (notification.id >= this.notificationCurrentId) {
            this.notificationCurrentId = notification.id + 1;
          }
        });
      }
      
      // Import Page Templates
      if (Array.isArray(data.pageTemplates)) {
        data.pageTemplates.forEach((template: PageTemplate) => {
          if (typeof template.createdAt === 'string') {
            template.createdAt = new Date(template.createdAt);
          }
          if (typeof template.updatedAt === 'string') {
            template.updatedAt = new Date(template.updatedAt);
          }
          
          this.pageTemplates.set(template.id, template);
          if (template.id >= this.pageTemplateCurrentId) {
            this.pageTemplateCurrentId = template.id + 1;
          }
        });
      }
      
      // Import Page Components
      if (Array.isArray(data.pageComponents)) {
        data.pageComponents.forEach((component: PageComponent) => {
          if (typeof component.createdAt === 'string') {
            component.createdAt = new Date(component.createdAt);
          }
          if (typeof component.updatedAt === 'string') {
            component.updatedAt = new Date(component.updatedAt);
          }
          
          this.pageComponents.set(component.id, component);
          if (component.id >= this.pageComponentCurrentId) {
            this.pageComponentCurrentId = component.id + 1;
          }
        });
      }
      
      // Import Custom Pages
      if (Array.isArray(data.customPages)) {
        data.customPages.forEach((page: CustomPage) => {
          if (typeof page.createdAt === 'string') {
            page.createdAt = new Date(page.createdAt);
          }
          if (typeof page.updatedAt === 'string') {
            page.updatedAt = new Date(page.updatedAt);
          }
          if (typeof page.publishedAt === 'string') {
            page.publishedAt = new Date(page.publishedAt);
          }
          
          this.customPages.set(page.id, page);
          if (page.id >= this.customPageCurrentId) {
            this.customPageCurrentId = page.id + 1;
          }
        });
      }
      
      this.saveData();
      return true;
    } catch (error) {
      console.error('Error importing data:', error);
      return false;
    }
  }
}

export const storage = new MemStorage();
